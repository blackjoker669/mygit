Redis事务定义：
	redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。
	事务在执行的过程中，不会被其他客户端发送过来的命令请求所打断

redis事务的主要作用就是串联多个命令防止别的命令插队。

1.监视事务操作对象：watch
	在监视的过程中，如果对象数据发生变化，则该事务将被取消。
2.开启事务：mutli
	输入mutil指令后，后续输入的操作数据指令将依次进入命令队列中，但不会立刻执行，
	组队过程中，如果出现报告错误，如出现语法问题，执行时整个队列都会被取消，自动取消事务。
	如果执行阶段某个命令出现错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。
3.执行事务：exec	
	输入exec后，redis会将命令队列中的命令依次执行。
4.删除\回滚事务：discard
	组队的过程中可以通过discard来放弃组队，即取消事务。	

Redis事务三特性：
	1.单独的隔离操作：
		事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送过来的命令请求所打断
	
	2.没有隔离级别的概念
		队列中的命令没有提交之前都不会实际的被执行，因为事务提交前，任何指令都不会被实例执行。
		
	3.不保证原子性
		redis同一个事务中如果有一条指令执行失败，其后的命令仍然会被执行，没有回滚。

事务锁：

	1.悲观锁：
		对事务操作的对象进行加锁，在事务执行过程中，将阻塞其他事务获得该数据，不允许访问(读)，
		事务操作结束后将会释放锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，
		读锁，写锁等，都是在做操作之前先上锁。Java中synchronized就是悲观锁思想的实现。
		
	2.乐观锁：冲突检查+数据更新
		总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，
		但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。
	
	CAS：Compare and Swap 比较和替换
	CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，
	那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。
	（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）
	CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；
	否则，不要更改该位置，只告诉我这个位置现在的值即可。”

	版本号机制：
	数据不加锁，即每个事务都能够对数据进行访问，但在操作(写)数据之前，将检查数据的版本号是否与原始数据一致，
	如果不一致则取消事务，如果版本号一致则执行事务，每次执行完事务之后，数据的版本号就会变更。