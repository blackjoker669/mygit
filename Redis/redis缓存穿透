数据倾斜：大量的数据放到了少量的节点上
布隆过滤器：过滤缓存穿透带来的无效请求
hash函数:
	1.hash值范围[0,length-1]，length是bit数组长度
	2.计算出来的hsah值足够散列

布隆算法：通过一定的错误率来换取空间
		通过bit数组来标识数据，然后传给hash函数，计算出一个hash值，放入bit数组。
		发生hash碰撞会产生错误。
		布隆算法是由于存在hash碰撞所以导致错误率。
	降低hash碰撞概率：
		1.加大数组长度，数组越长，hash值的可能性越多，进而降低hash碰撞
		2.增加hash函数的个数，增加标识数据的bit位数，一个hash函数代表一个bit位数，
		位数越多，hash函数计算得到的hash值相同的可能性越低
		hash函数的个数并不是越多越好，需要参考数组长度。
		
Redis集群的Hash一致性算法：
	借助一致性算法的思想。
	Redis集群Hash取模：
		假如有缓存数据data(kv)，将其分片存储在两个数据库redis1和redis2，对数据的key进行取模 ：hash(key)%2
		模为0则存入redis1，模为1则存入redis2.
		如果分片存储在三个数据库redis1、redis2和redis3，则取模：hash(key)%3
		模为0则存入redis1，模为1则存入redis2，模为2则存入redis3
	hash环：
	将redis服务器ip经过hash取模：hash(ip)%2^32，放入hash环上，同理，
	将data(kv)缓存数据也经过hash取模：hash(key)%2^32,放入处于hash环上的redis服务器。
	
		
什么是缓存穿透、缓存雪崩、缓存击穿？
	*缓存雪崩和缓存击穿的本质都是缓存穿透。缓存雪崩和缓存击穿是缓存穿透的特殊表现。
	
1.缓存穿透
	定义：穿过缓存层去访问数据库
	在缓存层中没有命中数据，进而去mysql中查询数据
	缓存穿透无法完全避免，但可以避免高频的、恶意的缓存穿透
	
	问题1：黑客通过一个固定非法请求去不断访问数据库
	解决：采用null再次缓存进行解决。
	问题2：黑客采用uuid这类请求不断访问数据库，如果采用null再次缓存，由于redis中的LRU、LFU等清除缓存算法，
	时间久了之后redis将把有用信息数据逐渐清楚并且存储大量的null值数据。
	解决：在redis和mysql之间加布隆过滤器，但会导致内存紧张。
	
	
2.缓存雪崩
	缓存层中，缓存的某些数据在某一个时刻突然失效或无法访问，导致大量的请求打向mysql数据库
	
	原因：
		1.redis中缓存的数据有效期是一致的
		解决：给每一条数据加一个随机的有效期，防止缓存的同时失效。
		2.redis数据库宕机
		解决：分布式存储缓存数据(分片集群)，防止缓存的同时失效。
		

3.缓存击穿
	缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，
	当这个key在失效的瞬间，持续的大并发就穿破缓存，大量请求直接打向数据库，就像在一个屏障上凿开了一个洞。
	一般公司不需要解决缓存击穿，因为没有访问量很大的热点数据，如“爆款”商品。
	解决：将热点key的过期时间设为永不过期，或使用分布式锁。
	
  