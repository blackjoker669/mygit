redis是单线程的，一次只处理一个请求
基于内存运行->内存
默认采用RDB持久化
1.RDB：Redis DataBase
	在指定时间间隔内将内存中的数据集快照写入磁盘，也就是sanpshot快照，它恢复时是将快照文件直接读到内存里，

RDB的备份：	
原理是redis会单独创建(fork)一个与当前进程一模一样的子进程来进行持久化，使用了"写时拷贝技术"，会先将数据写入到一个临时文件中，
待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，
这就确保了极高的性能，如果需要进行大规模数据的恢复，且对数据恢复的完整性不是非常敏感，那RDB方式要比AOF
方式更加高效。

RDB的缺点是最后一次持久化后的数据可能丢失(非正常关闭)。
优点：
	1.节省磁盘空间
	2.恢复速度块
	
2.AOF: Append of file

	以日志的形式来记录每个写操作，将Redis执行过的所有写指令都记录下来(不记录读操作),只许追加文件但不可以
	改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令
	从前到后执行一次以完成数据的恢复工作。
	
	AOF默认不开启，需要手动配置：
	appendonly no  -> appendonly yes
	设置备份文件名称：
	appendfilename "appendonly.aof"
	
	AOF采用文件追加方式，为了避免出现文件会越来越大这种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，
	Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 bgrewriteaof
			如：
			set a 1
			set a 123
			append a 456
			则在备份文件中，会以set a 123456的形式记录
	
	如何实现重写：
	AOF文件持续增长而过大时，会fork出一条新进程来将文件进行重写(先写临时文件，最后再覆盖),遍历新进程的内存中数据，
	记录每一条数据。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式
	重写了一个新的aof文件，这点和快照有点类似。
	
	何时重写：
	auto-aof-rewrite-percentage 100
	auto-aof-rewrite-min-size 64mb
	
	AOF的优点：
		1.备份机制更稳健，丢失数据概率更低。
		2.可读的日志文本，通过操作AOF稳健，可以处理误操作。
	缺点：
		1.比起RDB占用更多的磁盘资源
		2.恢复备份速度要慢
		3.每次读写都同步的化，有一定的性能压力
		4.存在个别bug，造成不能恢复。
	
	官方推荐两个都启用。
	如果对数据不敏感，可以单独选用RDB。
	不建议单独使用AOF，因为可能会出现bug。
	如果只是做内存缓存，可以都不用。
	
	Redis允许同时开启AOF和RDB，既保证了数据安全又使得进行备份等操作十分容易。
	此时重新启动Redis后Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少