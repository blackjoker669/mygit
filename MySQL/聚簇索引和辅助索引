InnoDB基于B*Tree
B*Tree是B+Tree的增强，在B+Tree的枝节点以及叶节点直接添加了双向指针。在范围查找方面提供了更好的性能
MySQL底层每次最少读取一个页page

重点:MySQL B+Tree索引构建过程
1.聚簇索引Btree结构(InnoDB独有，区=簇=extent=1MB)
	clustered index
	*概念：按照每个表的主键列构造一颗B+树，同时叶子节点中存放的就是整张表的数据行记录，也将聚簇索引的叶子节点称为数据页。
	
	InnoDB存储引擎，会按照聚簇索引有序的组织存储表的数据行，放到各个区的连续的数据页上。
	这些连续的数据页构成了聚簇索引的叶子节点，也就是说叶子节点就是原表数据。

聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。

构建前提:
	1. 建表时，指定了主键列(Primary Key)，MySQL InnoDB 会将主键作为聚簇索引列，比如id int auto_increment primary key 
	2. 如果没有指定主键，会自动选择唯一键(unique)的列，作为聚簇索引。
	3. 以上都没有，MySQL会自动生成隐藏聚簇索引。
作用：
	 有了聚簇索引之后，将来插入的数据行，在同一个区内，都会按照ID值的顺序，有序的在磁盘上存储数据。即顺序IO
	
结构：
	1. 在表数据行的基础上进行分页，16KB大小连续的存储空间，页与页之间是连续的，把每一页作为B+Tree的叶节点。
	2. 然后根据叶节点自动生成枝节点，枝节点存储每个叶节点的主键id(索引)的最小值，并生成每个值对应叶子节点的指针。
	3. 最后根据枝节点生成根节点，根节点存储每个枝节点的最小值，并生成每个值对应枝节点的指针。
	
	1段=多个区，1区=64页，1页=4块，1块=8扇区，1扇区=512B
				1区=1MB,  1页=16KB， 1块=4KB
				
	聚簇索引的优缺点

　　优点：

　　　　1.数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
　　　　2.聚簇索引对于主键的排序查找和范围查找速度非常快

　　缺点：

　　　　1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键
　　　　2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。
　　　　3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。
	

2.辅助索引Btree结构
	non-clustered index非聚簇索引，或secondary index二级索引
	需要手动创建。
	
	概念：在聚簇索引之上创建的索引称之为辅助索引，使用普通列作为条件构建的索引，辅助索引访问数据总是需要二次查找(通过聚簇索引再次查询)。
	
	作用：优化非聚簇索引的条件查询。
	
	单列辅助索引：
	alter table t1 add index idx(name); 使用t1表中的name列构建辅助索引
	1. 先将主键列和name列查询出来，然后对name列进行大小排序。
	2. 然后对数据行进行分页，每页存储连续的16KB大小的数据，且索引的存储需要单独申请空间，在每页的基础上生成叶子节点。
	3. 然后在叶子节点的基础上生成枝节点，每个枝节点存储叶子节点对应的最小值，每个最小值对应一个页，并生成指向最小值对应的叶子节点的指针。
	4. 最后根据枝节点生成根节点，根节点存储每个枝节点对应的最小值，每个最小值对应一个页，并生成每个最小值对应枝节点的指针。

	回表:辅助索引所查询出来的id值，需要在聚簇索引中再次进行查询，最后得到该非主键条件对应的数据行。
		注意：如果通过辅助索引查询能够完全覆盖需要的查询结果，则不需要进行回表操作。
		如：select id,name from TABLE_NAME where name='xx';
	
	回表的影响：
		1.IO量级变大(IO吞吐量)
		2.IO次数变大(每秒IO的次数)

聚簇索引和辅助索引的区别:
	1.聚簇索引的叶子节点包含全表数据行记录，辅助索引仅包含主键列和普通列数据
	2.聚簇索引使用主键列进行排序并分页，辅助索引使用普通列进行排序并分页
	3.聚簇索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块zd。
	4.两种索引B+树的构建过程一致，聚簇索引直接存储在数据行中，辅助索引存储在额外的存储空间。
	
辅助索引的细分：
1.单列索引 alter table t1 add index idx(name);
2.联合索引 alter table t1 add index idx(name,gender);
	说明：使用多列构建一个索引。
	最左列原则：
	1.查询条件中，必须包含最左列
	2.建立联合索引时，选择重复值少的列作为最左列
3.前缀索引	
	针对索引列值过长所建立的索引。列值过长会导致索引数高度增高。
	所以可以选择大字段的前面部分字符作为索引生成条件。
	
	MySQL中建议索引数高度3-4层。
	20-30列，列值长度合适，可存储800W行数据

B+tree索引高度影响因素
	1.索引字段较长: 采用前缀索引
	2.数据行过多： 分区表，归档表，分布式架构(大企业)
	3.数据类型: 选择合适的数据类型

聚簇索引的优势：

1.由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，
再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。

2.辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，
使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"。
也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。

3.聚簇索引适合用在排序的场合，非聚簇索引不适合

4.取出一定范围数据的时候，使用聚簇索引

5.二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据

6.可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。





















